import fs from 'node:fs'
import path from 'node:path'

const root = process.cwd()

const readLines = filePath => fs.readFileSync(filePath, 'utf-8').split(/\r?\n/)

const writeFileSafe = (filePath, content) => {
  fs.mkdirSync(path.dirname(filePath), { recursive: true })
  fs.writeFileSync(filePath, content.trim() + '\n', 'utf-8')
}

const stripMarkdownLinks = value => value.replace(/\[(.*?)\]\((.*?)\)/g, '$1')

const cleanSummaryLine = line => stripMarkdownLinks(line).replace(/`([^`]+)`/g, '$1').trim()

const extractSummary = chunk => {
  let inCodeBlock = false
  const collected = []
  for (const raw of chunk) {
    const line = raw.trim()
    if (line.startsWith('```')) {
      inCodeBlock = !inCodeBlock
      continue
    }
    if (inCodeBlock) continue
    if (!line) {
      if (collected.length > 0) break
      continue
    }
    if (line.startsWith('#') || line.startsWith('```') || line.startsWith('|')) continue
    if (line.startsWith('<') && line.endsWith('>')) continue
    if (line.startsWith('![')) continue
    if (line.startsWith('- ') || line.startsWith('* ')) {
      collected.push(cleanSummaryLine(line.slice(2)))
      break
    }
    collected.push(cleanSummaryLine(line))
    if (collected.join(' ').length >= 200) break
  }
  if (collected.length === 0) return null
  return collected.join(' ').replace(/\s+/g, ' ')
}

const extractBullets = (chunk, limit = 4) => {
  const bullets = []
  for (const raw of chunk) {
    const line = raw.trim()
    if (!line) {
      if (bullets.length > 0) break
      continue
    }
    if (line.startsWith('- ') || line.startsWith('* ')) {
      bullets.push(cleanSummaryLine(line.slice(2)))
      if (bullets.length >= limit) break
      continue
    }
    if (bullets.length > 0) break
  }
  return bullets
}

const extractCodeBlock = (chunk, maxLines = 12) => {
  const start = chunk.findIndex(line => line.trim().startsWith('```'))
  if (start === -1) return null
  const language = chunk[start].trim().slice(3).trim() || 'ts'
  const body = []
  for (let i = start + 1; i < chunk.length; i++) {
    const line = chunk[i]
    if (line.trim().startsWith('```')) break
    if (body.length < maxLines) {
      body.push(line)
    }
  }
  if (body.length === 0) return null
  const code = body.join('\n').trim()
  if (!code) return null
  return `\n\n\`\`\`${language}\n${code}\n\`\`\``
}

const splitByHeading = (lines, pattern) => {
  const groups = []
  let current = null
  for (const line of lines) {
    const match = line.match(pattern)
    if (match) {
      if (current) groups.push(current)
      current = { heading: match[1].trim(), content: [] }
    } else if (current) {
      current.content.push(line)
    }
  }
  if (current) groups.push(current)
  return groups
}

const condenseApiDocs = () => {
  const inputPath = path.join(root, 'prompts', 'API-GENERATED.md')
  const outputPath = path.join(root, 'prompts', 'API-REFERENCE.md')
  const lines = readLines(inputPath)
  const sections = splitByHeading(lines, /^##\s+(.*)$/)

  const parts = [
    '# Script Kit API Reference (Condensed)',
    '',
    'Generated by scripts/condense-generation-assets.mjs. One summary, key bullets, and a trimmed example per API topic.',
  ]

  for (const section of sections) {
    const childSections = splitByHeading(section.content, /^###\s+(.*)$/)
    if (childSections.length === 0) continue
    parts.push(`\n## ${section.heading}`)
    for (const child of childSections) {
      const summary = extractSummary(child.content)
      const bullets = extractBullets(child.content, 3)
      const code = extractCodeBlock(child.content, 8)
      parts.push(`\n### ${child.heading}`)
      if (summary) parts.push(`> ${summary}`)
      for (const item of bullets) parts.push(`- ${item}`)
      if (code) parts.push(code.trimStart())
    }
  }

  writeFileSafe(outputPath, parts.join('\n'))
}

const condenseGuide = () => {
  const inputPath = path.join(root, 'prompts', 'GUIDE.md')
  const outputPath = path.join(root, 'prompts', 'GUIDE-PLAYBOOK.md')
  const lines = readLines(inputPath)
  const sections = splitByHeading(lines, /^##\s+(.*)$/)

  const parts = [
    '# Script Kit Playbook (Condensed)',
    '',
    'Generated by scripts/condense-generation-assets.mjs. Each topic keeps the first summary and the first example snippet.',
  ]

  for (const section of sections) {
    const summary = extractSummary(section.content)
    const bullets = extractBullets(section.content, 3)
    const code = extractCodeBlock(section.content, 8)
    parts.push(`\n## ${section.heading}`)
    if (summary) parts.push(`> ${summary}`)
    for (const item of bullets) parts.push(`- ${item}`)
    if (code) parts.push(code.trimStart())
  }

  writeFileSafe(outputPath, parts.join('\n'))
}

const condenseDocsMini = () => {
  const inputPath = path.join(root, 'prompts', 'docs-mini.md')
  const outputPath = path.join(root, 'prompts', 'docs-mini-condensed.md')
  if (!fs.existsSync(inputPath)) return

  const lines = readLines(inputPath)
  const sections = splitByHeading(lines, /^##\s+(.*)$/)

  const parts = [
    '# Script Kit Prompt Index (Condensed)',
    '',
    'Generated by scripts/condense-generation-assets.mjs. Each prompt keeps notes and omits verbose code samples.',
  ]

  for (const section of sections) {
    const summary = extractSummary(section.content)
    const bullets = extractBullets(section.content, 4)
    parts.push(`\n## ${section.heading.replace(/^\d+\.\s*/, '')}`)
    if (summary) parts.push(`> ${summary}`)
    for (const item of bullets) parts.push(`- ${item}`)
  }

  writeFileSafe(outputPath, parts.join('\n'))
}

const countBraces = line => {
  const open = (line.match(/\{/g) || []).length
  const close = (line.match(/\}/g) || []).length
  return open - close
}

const truncateBlock = (lines, { maxBodyLines = 20, ellipsis = '  ...' } = {}) => {
  if (lines.length <= 2) return lines
  const header = lines[0]
  const footer = lines[lines.length - 1]
  const body = lines.slice(1, -1).filter(Boolean)
  if (body.length <= maxBodyLines) return lines
  return [header, ...body.slice(0, maxBodyLines), ellipsis, footer]
}

const minifyTypes = () => {
  const typesDir = path.join(root, 'kit', 'types')
  const outputPath = path.join(root, 'prompts', 'kit-types.min.d.ts')
  const files = fs
    .readdirSync(typesDir)
    .filter(file => file.endsWith('.ts') || file.endsWith('.d.ts'))
    .sort()

  const chunks = ['// Condensed kit types generated by scripts/condense-generation-assets.mjs']

  const MAX_INTERFACE_LINES = 12
  const MAX_TYPE_LINES = 12

  const allowedTypeNames = new Set([
    'Choice',
    'Choices',
    'ScoredChoice',
    'Action',
    'ActionsConfig',
    'Shortcut',
    'Panel',
    'Preview',
    'PromptConfig',
    'PromptBounds',
    'PromptDb',
    'PromptData',
    'Prompt',
    'Flags',
    'FlagsObject',
    'Flag',
    'Arg',
    'Args',
    'UpdateArgs',
    'Select',
    'Grid',
    'Drop',
    'Div',
    'Form',
    'Fields',
    'FieldConfig',
    'PathFn',
    'Env',
    'EnvConfig',
    'DB',
    'Store',
    'Run',
    'Wait',
    'Inspect',
    'Browse',
    'Download',
    'Md',
    'Compile',
    'Uuid',
    'Globby',
    'IsFile',
    'IsDir',
    'IsBin',
    'FormatDate',
    'Trash',
    'Git',
    'Degit',
    'OpenApp',
    'CreateGist',
    'Npm',
    'AttemptImport',
    'SilentAttemptImport',
    'MemoryMap',
    'Show',
    'Hide',
    'SetPanel',
    'SetPrompt',
    'SetPreview',
    'SetIgnoreBlur',
    'GetClipboardHistory',
    'RemoveClipboardItem',
    'ClearClipboardHistory',
    'SetScoredChoices',
    'SetSelectedChoices',
    'GroupChoices',
    'Preload',
    'GetMediaDevices',
    'GetTypedText',
    'Toast',
    'Submit',
    'PreventSubmit',
    'Exit',
    'KitPath',
    'KenvPath',
    'TmpPath',
    'GetScripts',
    'SelectScript',
  ])

  for (const file of files) {
    const source = fs.readFileSync(path.join(typesDir, file), 'utf-8')
    const withoutBlock = source.replace(/\/\*[\s\S]*?\*\//g, '')
    const withoutLine = withoutBlock.replace(/^\s*\/\/.*$/gm, '')
    const rawLines = withoutLine.split(/\r?\n/).map(line => line.trim()).filter(line => line.length > 0)

    const processed = []
    let capturing = null
    let braceBalance = 0

    const flushCapture = () => {
      if (!capturing) return
      if (capturing.skip) {
        capturing = null
        braceBalance = 0
        return
      }
      const lines = capturing.lines
      const kind = capturing.kind
      if (kind === 'interface') {
        processed.push(...truncateBlock(lines, { maxBodyLines: MAX_INTERFACE_LINES }))
      } else if (kind === 'type' && capturing.hasBlock) {
        processed.push(...truncateBlock(lines, { maxBodyLines: MAX_TYPE_LINES }))
      } else {
        processed.push(...lines)
      }
      capturing = null
      braceBalance = 0
    }

    let skipContinuation = false

    for (const line of rawLines) {
      if (skipContinuation) {
        if (line.startsWith('|') || line.startsWith('&')) {
          continue
        }
        skipContinuation = false
      }

      const interfaceMatch = line.startsWith('export interface ')
      const typeMatch = line.startsWith('export type ') && line.includes('{')
      const declareMatch =
        line.startsWith('declare namespace ') ||
        line.startsWith('declare module ') ||
        line.startsWith('declare global ')
      const typeNoBlockMatch = line.startsWith('export type ') && !line.includes('{')

      if (!capturing && typeNoBlockMatch) {
        const name = (line.match(/^export\s+type\s+([A-Za-z0-9_]+)/) || [])[1]
        if (name && !allowedTypeNames.has(name)) {
          skipContinuation = true
          continue
        }
      }

      if (!capturing && (interfaceMatch || typeMatch || declareMatch)) {
        const typeNameMatch = line.match(/^export\s+(?:interface|type)\s+([A-Za-z0-9_]+)/)
        const name = typeNameMatch ? typeNameMatch[1] : null
        const skip = name ? !allowedTypeNames.has(name) : false
        capturing = {
          kind: interfaceMatch ? 'interface' : typeMatch ? 'type' : 'declare',
          lines: [line],
          skip,
          hasBlock: line.includes('{'),
        }
        braceBalance = countBraces(line)
        if (braceBalance === 0) {
          flushCapture()
        }
        continue
      }

      if (capturing) {
        capturing.lines.push(line)
        if (capturing.hasBlock || line.includes('{') || line.includes('}')) {
          braceBalance += countBraces(line)
        }
        if (capturing.hasBlock && braceBalance === 0) {
          flushCapture()
        }
        continue
      }

      processed.push(line)
    }

    flushCapture()

    // Remove duplicate blank separators
    const condensed = []
    for (const line of processed) {
      if (line === '...' && condensed[condensed.length - 1] === '...') continue
      condensed.push(line)
    }

    chunks.push(`\n// File: ${file}\n${condensed.join('\n')}`)
  }

  writeFileSafe(outputPath, chunks.join('\n'))
}

const run = () => {
  condenseApiDocs()
  condenseGuide()
  condenseDocsMini()
  minifyTypes()
}

run()
