This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by â‹®---- delimiter), security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: lib/generation.ts, prompts/SYSTEM.md, prompts/GUIDE-PLAYBOOK.md, prompts/API-REFERENCE.md, prompts/kit-types.min.d.ts, prompts/docs-mini-condensed.md, scripts/condense-generation-assets.mjs, app/api/generate-ai-gateway/route.ts, app/api/generate-ai-gateway/prompt.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by â‹®---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
app/
  api/
    generate-ai-gateway/
      prompt.ts
      route.ts
lib/
  generation.ts
prompts/
  API-REFERENCE.md
  docs-mini-condensed.md
  GUIDE-PLAYBOOK.md
  kit-types.min.d.ts
  SYSTEM.md
scripts/
  condense-generation-assets.mjs
```

# Files

## File: prompts/API-REFERENCE.md
````markdown
# Script Kit API Reference (Condensed)

Generated by scripts/condense-generation-assets.mjs. One summary, key bullets, and a trimmed example per API topic.

## Intro

### Welcome to Script Kit! ðŸ‘‹
> Script Kit provides an opinionated set of global APIs meant to streamline the process of writing scripts. Many of them (such as prompts) are meant to interact with the app, but there are also many common APIs for working with files, etc, that are simply built-in node or third-party libraries exposed as globals.

### Play with Examples in the App
> With Script Kit open, type docs and hit enter.

## Basics

### Script Imports
> Script Kit Scripts start with importing the SDK:
```ts
import '@johnlindquist/kit'
```

### Top-Level await
> All scripts are top-level await and essentially run top to bottom. Expect to see a lot of await in the scripts.
```ts
const downloadMarkdownPattern = home('Downloads', '*.md')
const files = await globby(downloadMarkdownPattern)

let totalContent = ''
for await (const file of files) {
  const content = await readFile(file, 'utf8')
  totalContent += content
}
```

### Global Helpers
> All scripts are standard node.js scripts with added helpers from the SDK. Many of the most common helpers are provided in the global scope to save you from having to import them. For example, the follow script requires no imports:
```ts
const url = 'https://raw.githubusercontent.com/johnlindquist/kit-docs/refs/heads/main/API.md'
const response = await get(url)
const content = response.data
const apiPath = home('Downloads', 'API.md')
await writeFile(apiPath, content)
```

### Script Metadata
> All metadata is optional. There are two metadata modes based on your preferences:
```ts
// Name: My Amazing Script
```

### Metadata Typed Global
> Introduced in Script Kit v3, these allow a fully-typed, autocomplete experience:âˆ«
```ts
metadata = {
  name: "My Amazing Script
}
```

### metadata
> The metadata object can include:
- name: Display name in Script Kit UI (defaults to filename)
- author: Creator's name
- description: Brief script summary
```ts
name: "Metadata Example",
  description: "This is an example of how to use metadata in a script",
  author: "John Lindquist",
};
```

## AI

### Setup
> Script Kit automatically loads AI-related environment variables from your ~/.kenv/.env file. To configure your default AI provider, model, and other options, add the following variables to your ~/.kenv/.env:
- AI_DEFAULT_PROVIDER â€” Default AI provider (e.g. openai, anthropic, google, xai, openrouter)
- AI_DEFAULT_MODEL â€” Default model for the provider (e.g. gpt-4o, claude-3-opus-20240229)
- AI_DEFAULT_TEMPERATURE â€” Default temperature for completions (e.g. 0.7)
```env
AI_DEFAULT_PROVIDER=anthropic
AI_DEFAULT_MODEL=claude-3-opus-20240229
AI_DEFAULT_TEMPERATURE=0.7
AI_DEFAULT_MAX_TOKENS=1000
```

### ai
> The ai helper creates a text generation function using a prompt. Use it to generate text completions based on user input or other data.
- Only improve the text.
- Do not include any other text in your response.
- Avoid using markdown formatting.
```ts
const emojiStoryGenerator = ai('Generate a story using only emoji, no text.')
const story = await emojiStoryGenerator('Epic Fantasy')
await editor(story)
```

## AI Translation

### assistant
> The assistant helper creates an AI assistant that can maintain context and handle multi-turn conversations. You can add user and system messages, and stream responses to the UI.
```ts
const downloadsPath = home('Downloads')
const files = await readdir(downloadsPath)

const jester = assistant('Tell a joke about these file names.')
jester.addUserMessage(files.join('\n'))

await editor({
  onInit: async () => {
```

## Assistant with Tools

### generate
> The generate helper allows you to generate structured data from text using a schema (such as a Zod schema). This is useful for extracting information, performing analysis, or ensuring the output matches a specific format.
```ts
const result = await generate(
  'Generate 10 random users as an array in a property called "users"',
  z.object({
    users: z.array(
      z.object({
        firstName: z.string(),
        lastName: z.string(),
        age: z.number(),
```

## Sentiment Analysis

### Switching AI Providers
> Script Kit supports multiple AI providers out of the box: openai, anthropic, google, xai, and openrouter.
- openai
- anthropic
- google
```ts
const result = await ai('Say hello', { model: 'anthropic:claude-3-opus-20240229' })
```

### Provider: ${selectedProvider.name}

### Model: ${model}
> **Prompt:**

## Prompts

### arg
> Accept text input from the user.
- Accept text input from the user.
- Optionally provide a list of choices filtered by the text input.
- Optionally provide a list of actions to trigger when the user presses a shortcut.
```ts
let value = await arg()
```

### mini
> Same API as arg, but with a compact format.
```ts
let name = await mini('Enter your name')
```

### micro
> Same API as arg, but with a tiny, adorable UI.
```ts
let name = await micro('Enter your name')
```

### env
> Load an env var if it exists, prompt to set the env var if not:
```ts
// Write write "MY_ENV_VAR" to ~/.kenv/.env
let MY_ENV_VAR = await env('MY_ENV_VAR')
```

### editor
> The editor function opens a text editor with the given text. The editor is a full-featured "Monaco" editor with syntax highlighting, find/replace, and more. The editor is a great way to edit or update text to write a file. The default language is markdown.
```ts
let content = await editor()
```

### div
> div displays HTML. Pass a string of HTML to div to render it. div is commonly used in conjunction with md to render markdown.
```ts
await div(`Hello world!`)
```

### Thanks for coming to my demo
> This is a list
- This is a list
- This is another item
- This is the last item
```ts
#### div with submit links
```

### term
> The term function opens a terminal window. The terminal is a full-featured terminal, but only intended for running commands and CLI tools that require user input. term is not suitable for long-running processes (try exec instead).
```ts
await term(`cd ~/.kenv/scripts && ls`)
```

### template
> The template prompt will present the editor populated by your template. You can then tab through each variable in your template and edit it.
```ts
let text = await template(`Hello $1!`)
```

### hotkey
> The hotkey prompt allows you to press modifier keys, then submits once you've pressed a non-monodifier key. For example, press command then e to submit key info about the command and e keys:
```json
{
  "key": "e",
  "command": true,
  "shift": false,
  "option": false,
  "control": false,
  "fn": false,
  "hyper": false,
```

### drop
> Use await drop() to prompt the user to drop a file or folder.
```ts
// Dropping text or an image from the browser returns a string
let fileInfos = await drop()

let filePaths = fileInfos.map(f => f.path).join(',')

await div(md(filePaths))
```

### fields
> The fields prompt allows you to rapidly create a form with fields.
```ts
let [first, last] = await fields(['First name', 'Last name'])
```

### form
> Use an HTML form which returns an Object based on the names of the form fields.
```ts
let result = await form(`
<div class="p-4">
    <input type="text" name="textInput" placeholder="Text Input" />
    <input type="password" name="passwordInput" placeholder="Password" />
    <input type="email" name="emailInput" placeholder="Email" />
    <input type="number" name="numberInput" placeholder="Number" />
    <input type="date" name="dateInput" placeholder="Date" />
    <input type="time" name="timeInput" placeholder="Time" />
```

### chat
> A chat prompt. Use chat.addMessage() to insert messages into the chat.
```ts
await chat({
  onInit: async () => {
    chat.addMessage({
      // Note: text and position are implemented, there are other properties that are a WIP
      text: 'You like Script Kit',
      position: 'left',
    })
```

### selectFile
> Prompt the user to select a file using the Finder dialog:
```ts
let filePromptMessage = 'Select a file to upload'
let filePath = await selectFile(filePromptMessage)
let text = await readFile(filePath, 'utf8')
let gist = await createGist(text)
```

### selectFolder
> Prompt the user to select a folder using the Finder dialog:
```ts
let promptMessage = 'Select a folder for your project'
let folderPath = await selectFolder(promptMessage)

let files = await readdir(folderPath)

await editor(files.join('\n'))
```

### path
> The path prompt allows you to select a file or folder from the file system. You navigate with tab/shift+tab (or right/left arrows) and enter to select.
```ts
let selectedFile = await path()
```

### select
> select lets you choose from a list of options.
```ts
// Return an array of selected items
const multipleChoice = await select('Select one or more developer', [
  'John',
  'Nghia',
  'Mindy',
  'Joy',
])
```

### inspect
> inspect takes an object and writes out a text file you can use to read/copy/paste the values from:
```ts
let response = await get('https://swapi.dev/api/people/1/')
await inspect(response.data)
```

### dev
> dev Opens a standalone instance of Chrome Dev Tools so you can play with JavaScript in the console. Passing in an object will set the variable x to your object in the console making it easy to inspect.
```ts
dev()
```

### find
> A file search prompt
```ts
let filePath = await find('Search in the Downloads directory', {
  onlyin: home('Downloads'),
})

await revealFile(filePath)
```

### webcam
> Prompt for webcam access. Press enter to capture an image buffer:
```ts
let buffer = await webcam()
let imagePath = tmpPath('image.jpg')
await writeFile(imagePath, buffer)
await revealFile(imagePath)
```

### mic
> Record from the mic, get a buffer back
```ts
const tmpMicPath = tmpPath('mic.webm')

const buffer = await mic()

await writeFile(tmpMicPath, buffer)
await playAudioFile(tmpMicPath)
```

### eyeDropper
> Grab a color from your desktop
```ts
{
    "sRGBHex": "#e092d9",
    "rgb": "rgb(224, 146, 217)",
    "rgba": "rgba(224, 146, 217, 1)",
    "hsl": "hsl(305, 56%, 73%)",
    "hsla": "hsla(305, 56%, 73%, 1)",
    "cmyk": "cmyk(0%, 35%, 3%, 12%)"
  }
```

## Choices

### formatChoices
> Formats an array of choices.
- If a choice is not an object, it is converted to a basic choice object.
- If a choice has a nested choices array (i.e. represents a group), then:

## Advanced

### Actions (cmd+k)
> Actions are available on all prompts. Actions allow you to insert custom behaviors outside of the normal flow of the script:
```ts
const result = await arg(
  'What is your name?',
  ['John', 'Mindy', 'Ben'],
  //   Define an Array of Actions
  [
    {
      name: 'Submit Joy',
      shortcut: `${cmd}+j`,
```

### flag
> A flag is almost exclusively used for the CLI, rarely with a prompt. When using a CLI script:
```bash
my-script --debug --exclude "*.md"
```

### css
> You can inject css into any prompt to override styles
```ts
await div({
  html: md(`# Hello World
    
<p style="color: red;">This is a note</p>
    `),
  css: `
  body{
    background-color: white !important;
```

### onTab
> onTab allows you to build a menu where prompts are organized under a tab. Press Tab/Shift+Tab to navigate between prompts.
```ts
onTab('People', async event => {
  await arg('Select a person', ['John', 'Mindy', 'Ben'])
})

onTab('Animals', async event => {
  await arg('Select an animal', ['Dog', 'Cat', 'Bird'])
})
```

### openActions
> Manually open the actions menu

## Alerts

### beep
> Beep the system speaker:
```ts
await beep()
```

### say
> Say something using the built-in text-to-speech:
```ts
await say('Done!')
```

### notify
> Send a system notification
```ts
await notify('Attention!')
```

## System

### setSelectedText
> Paste text into the focused app. Literally triggers a "cmd/ctrl+v", so expect a similar behavior.
```ts
await setSelectedText('Hello from Script Kit!')
```

## getSelectedText

### clipboard
> Read and write to the system clipboard
```ts
// Write and read text to the clipboard
await clipboard.writeText('Hello from Script Kit!')
const result = await clipboard.readText()
await editor(result)
```

### copy
> Copy a string to the clipboard. A simple alias for "clipboard.writeText()"

### paste
> Grab a string from the clipboard into the script. A simple alias for "clipboard.readText()"

### mouse
> > Note: Please use with caution
```ts
await mouse.move([
  { x: 100, y: 100 },
  { x: 200, y: 200 },
])
await mouse.leftClick()
await wait(100)
await mouse.rightClick()
await wait(100)
```

### keyboard
> > Note: Please use with caution
```ts
prompt: false, // 99% of the time you'll want to hide the prompt
};
await keyboard.type("Hello, world!");
```

## Widget

### widget
> A widget creates a new window using HTML. The HTML can be styled via Tailwind CSS class names. Templating and interactivity can be added via petite-vue.
```ts
await widget(`<h1 class="p-4 text-4xl">Hello World!</h1>`)
```

## Vite

### vite
> A vite generates a vite project and opens it in its own window.
```ts
const { workArea } = await getActiveScreen()

// Generates/opens a vite project in ~/.kenv/vite/project-path
const viteWidget = await vite('project-path', {
  x: workArea.x + 100,
  y: workArea.y + 100,
  width: 640,
  height: 480,
```

## Commands

### exec
> exec uses allows you to run shell commands within your script:
```ts
let result = await exec(`ls -la`, {
  cwd: home(), // where to run the command
  shell: '/bin/zsh', // if you're expecting to use specific shell features/configs
  all: true, // pipe both stdout and stderr to "all"
})

inspect(result.all)
```

## Pro APIs

### term
> Opens a built-in Terminal window.
- Can run interactive commands
- Supports custom working directory and shell
```ts
await term(`cd ~/.kenv/scripts && ls`)
```

### showLogWindow
> Opens a logs window to display script output.
- Displays output from all scripts run in the current session
```ts
await showLogWindow()
```

## Platform APIs

### scatterWindows
> Evenly spaces out all open windows across the screen in a neat grid.
- Only tested on macOS.
- May require accessibility permissions if it's moving windows across multiple monitors.
```ts
await scatterWindows()
```

### focusKitWindow
> Brings the Script Kit window into focus.
- Only tested on macOS.
- May require accessibility permissions.
```ts
await focusKitWindow()
```

### attemptScriptFocus
> Attempts to bring the Script Kit window into focus.
- Only tested on macOS.
- May require accessibility permissions.
```ts
await attemptScriptFocus()
```

### getKitWindows
> Retrieves the Script Kit window objects.
- Only tested on macOS.
- May require accessibility permissions.
```ts
let windows = await getKitWindows()
```

### focusWindow
> Brings a specific window into focus.
- Only tested on macOS.
- May require accessibility permissions.
```ts
await focusWindow(12345)
```

### focusAppWindow
> Brings a specific application window into focus.
- Only tested on macOS.
- May require accessibility permissions.
```ts
await focusAppWindow('Google Chrome', 'Script Kit - Google Chrome')
```

### setWindowPosition
> Sets the position of a specific window.
- Only tested on macOS.
- May require accessibility permissions.
```ts
await setWindowPosition(12345, 100, 200)
```

### setWindowPositionByIndex
> Sets the position of a window based on its index.
- Only tested on macOS.
- May require accessibility permissions.
```ts
await setWindowPositionByIndex(0, 100, 200)
```

### scatterWindows
> Evenly spaces out all open windows across the screen in a neat grid.
- Only tested on macOS.
- May require accessibility permissions if it's moving windows across multiple monitors.
```ts
await scatterWindows()
```

### organizeWindows
> Organizes windows in a specific way.
- Only tested on macOS.
- May require accessibility permissions.
```ts
await organizeWindows({
  direction?: "horizontal" | "vertical",
  padding?: number,
  ...
}): Promise<string>
```

### tileWindow
> Tiles a specific window.
- Only tested on macOS.
- May require accessibility permissions.
```ts
await tileWindow(12345, {
  direction: 'horizontal',
  padding: 10,
})
```

### scrapeSelector
> Scrapes a webpage using a CSS selector.
```ts
let text = await scrapeSelector('https://example.com', '#main-content')
```

### scrapeAttribute
> Scrapes a webpage and extracts an attribute value.
```ts
let src = await scrapeAttribute('https://example.com', 'img', 'src')
```

### getScreenshotFromWebpage
> Captures a screenshot of a webpage.
```ts
let buffer = await getScreenshotFromWebpage("https://example.com", {
  width?: number,
  height?: number,
  ...
}): Promise<Buffer>
```

### getWebpageAsPdf
> Converts a webpage to a PDF.
```ts
let buffer = await getWebpageAsPdf('https://example.com', {
  width: 800,
  height: 600,
})
```

### applescript
> Executes an applescript string
- Only tested on macOS
- May require additional permissions or configurations
```ts
let result = await applescript(`
tell application "Finder"
  return name of every disk
end tell
`)
```

### lock
> Locks the screen.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await lock()
```

### logout
> Logs out the current user.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await logout()
```

### shutdown
> Shuts down the computer.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await shutdown()
```

### shutdown
> Shuts down the computer.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await shutdown()
```

### sleep
> Puts the computer to sleep.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await sleep()
```

### sleep
> Puts the computer to sleep.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await sleep()
```

### sleep
> Puts the computer to sleep.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await sleep()
```

### fileSearch
> Searches for files on the filesystem.
- Only tested on macOS
- May require additional permissions or configurations
```ts
async function fileSearch(query: string, options?: {
  onlyin?: string,
  ...
}): Promise<string[]>
```

### copyPathAsImage
> Copies a file path as an image to the clipboard.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await copyPathAsImage('/path/to/file.txt')
```

### copyPathAsImage
> Copies a file path as an image to the clipboard.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await copyPathAsImage('/path/to/file.txt')
```

### copyPathAsImage
> Copies a file path as an image to the clipboard.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await copyPathAsImage('/path/to/file.txt')
```

### getWindows
> Retrieves information about open windows.
- Only tested on macOS
- May require additional permissions or configurations
```ts
let windows = await getWindows()
```

### getWindowsBounds
> Retrieves the bounds of open windows.
- Only tested on macOS
- May require additional permissions or configurations
```ts
let bounds = await getWindowsBounds()
```

## Utils

### edit
> Open a file using the KIT_EDITOR env variable
```ts
const zshrcPath = home('.zshrc')
await edit(zshrcPath)
```

### run
> Run another script from the same kenv
```ts
// Assuming you have a "hello-world.ts" script next to this file
await run('hello-world')
```

### home
> Create a path relative to the user's home directory
```ts
const downloadsPath = home('Downloads')
const downloadedFileNames = await readdir(downloadsPath)
await editor(JSON.stringify(downloadedFileNames, null, 2))
```

### get
> An alias for axios.get
```ts
const result = await get('https://jsonplaceholder.typicode.com/todos/1')

await editor(JSON.stringify(result.data))
```

### post
> An alias for axios.post
```ts
const result = await post('https://jsonplaceholder.typicode.com/posts', {
  title: 'foo',
  body: 'bar',
  userId: 1,
})

await editor(JSON.stringify(result.data))
```

### put
> An alias for axios.put
```ts
const result = await put('https://jsonplaceholder.typicode.com/posts/1', {
  title: 'foo',
})

await editor(JSON.stringify(result.data))
```

### patch
> An alias for axios.patch
```ts
const result = await patch('https://jsonplaceholder.typicode.com/posts/1', {
  title: 'foo',
})

await editor(JSON.stringify(result.data))
```

### del
> An alias for axios.delete
```ts
const result = await del('https://jsonplaceholder.typicode.com/posts/1')

await editor(JSON.stringify(result.data))
```

### download
> Download a file from a URL
```ts
const url = 'https://github.com/johnlindquist/kit/archive/refs/heads/main.zip'
const destination = home('Downloads')

await download(url, destination)
```

### replace
> Replace a string or regex in one or more files
```ts
const mdPath = kenvPath('sticky.md')

await replace({
  files: [mdPath],
  from: /nice/g, // replace all instances of "nice"
  to: 'great',
})
```

### md
> Convert markdown to HTML for rendering in prompts
- Thanks for using Script Kit!
```ts
const html = md(`# You're the Best

* Thanks for using Script Kit!
`)

await div(html)
```

### compile
> Create a handlebars template compiler
```ts
const compiler = compile(`
Hello {{name}}

Have a {{mood}} day!

{{#if from}}
From {{author}}
{{/if}}
```

### uuid
> Generate a UUID
```ts
const id = uuid()
await editor(id)
```

### globby
> Glob a list of files
```ts
const kenvScripts = kenvPath('scripts', '*.ts')
const kenvScriptlets = kenvPath('scriptlets', '*.md')

const pathsForScriptsAndScriptlets = await globby([kenvScripts, kenvScriptlets])
await editor(JSON.stringify(pathsForScriptsAndScriptlets, null, 2))
```

### isFile
> Check if a path is a file
```ts
const testingIsFileTxtPath = home('testing-isFile.txt')

const isTestingFile = await isFile(testingIsFileTxtPath)
if (!isTestingFile) {
  await writeFile(testingIsFileTxtPath, 'Hello World')
}

const content = await readFile(testingIsFileTxtPath, 'utf8')
```

### isDir
> Check if a path is a directory

### isBin
> Check if a path can be executed

### browse
> Open a URL in the default browser.
```ts
// When executing a command without UI, "hide" allows you to instantly hide the UI rather than waiting for the command to finish
await hide()
await browse('https://scriptkit.com')
```

### formatDate
> Formats a date

### trash
> Moves files or directories to the trash.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await trash('/path/to/file.txt')
```

### git
> Git utility functions.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await git.clone('https://github.com/user/repo.git', '/path/to/repo')
```

### degit
> Clones a GitHub repository using degit.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await degit('https://github.com/user/repo.git', '/path/to/repo')
```

### openApp
> Opens an application.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await openApp('Google Chrome')
```

### createGist
> Creates a GitHub gist.
- Only tested on macOS
- May require additional permissions or configurations
```ts
let gistUrl = await createGist({
  description: 'My awesome gist',
  public: true,
  files: {
    'hello.txt': {
      content: 'Hello, world!',
    },
  },
```

### npm
> > Deprecated: Use standard import instead.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await npm('lodash')
```

### attemptImport
> Attempts to import a module.
```ts
let module = await attemptImport('lodash')
```

### silentAttemptImport
> Attempts to import a module silently.
- Only tested on macOS
- May require additional permissions or configurations
```ts
let module = await silentAttemptImport('lodash')
```

### store
> Stores data in a persistent key-value store.
- Only tested on macOS
- May require additional permissions or configurations
```ts
await store.set('myKey', 'myValue')
let value = await store.get('myKey')
```

### db
> An extremely simple database that persists to a file.
```ts
// Pre-populate the database with some items

const peopleDb = await db({
  people: [
    {
      name: 'John',
      age: 30,
      city: 'San Francisco',
```

### memoryMap
> Manages a memory map of objects.
```ts
memoryMap.set('myKey', { myObject: true })
let value = memoryMap.get('myKey')
```

### show
> Shows the main prompt.
```ts
await show()
```

### hide
> Hides the main prompt.
```ts
await hide()
```

### blur
> Returns focus to the previous app.
```ts
import { URL, fileURLToPath } from 'node:url'

await editor({
  onInit: async () => {
    const { workArea } = await getActiveScreen()
    const topLeft = { x: workArea.x, y: workArea.y }
    const size = { height: 900, width: 200 }
    await setBounds({
```

### setPanel
> Sets the panel content.
```ts
await setPanel('<h1>Hello, world!</h1>')
```

### setPrompt
> Sets the prompt content.
```ts
await setPrompt('<h1>Enter your name:</h1>')
```

### setPreview
> Sets the preview content.
```ts
await setPreview('<h1>Preview</h1>')
```

### setIgnoreBlur
> Sets whether to ignore blur events.
```ts
await setIgnoreBlur(true)
```

### getClipboardHistory
> Gets the clipboard history from the in-memory clipboard
```ts
const history = await getClipboardHistory()
const text = await arg('Select from clipboard history', history)
await editor(text)
```

### removeClipboardItem
> Removes an item from the clipboard.
```ts
await removeClipboardItem(item)
```

### clearClipboardHistory
> Clears the clipboard history.
```ts
await clearClipboardHistory()
```

### setScoredChoices
> Sets scored choices for a prompt.
```ts
await setScoredChoices([
  { name: 'John', score: 0.9 },
  { name: 'Mindy', score: 0.8 },
  { name: 'Joy', score: 0.7 },
])
```

### setSelectedChoices
> Sets selected choices for a prompt.
```ts
await setSelectedChoices(['John', 'Mindy'])
```

### groupChoices
> Groups choices for a prompt.
```ts
await groupChoices([
  { name: 'Group 1', choices: ['John', 'Mindy'] },
  { name: 'Group 2', choices: ['Joy'] },
])
```

### preload
> Preloads data for a prompt.
```ts
await preload({
  name: 'John',
  age: 40,
})
```

### select
> Prompts the user to select one or more options.
```ts
// Return an array of selected items
const multipleChoice = await select('Select one or more developer', [
  'John',
  'Nghia',
  'Mindy',
  'Joy',
])
```

### grid
> Prompts the user to select one or more options in a grid layout.
```ts
let multipleChoice = await grid('Select one or more developer', ['John', 'Nghia', 'Mindy', 'Joy'])
```

### getMediaDevices
> Retrieves available media devices.
```ts
let devices = await getMediaDevices()
```

### getTypedText
> Retrieves typed text from the user.
```ts
let text = await getTypedText()
```

### toast
> Displays a small pop-up notification inside the Script Kit window.
```ts
await toast('Hello from Script Kit!', {
  autoClose: 3000, // close after 3 seconds
  pauseOnFocusLoss: false,
})
```

### submit
> Forcefully submit a value from an open prompt
```ts
const result = await arg(
  {
    placeholder: "Pick one in under 3 seconds or I'll pick one for you",
    onInit: async () => {
      await wait(3000)
      submit('broccoli') //forces a submission
    },
  },
```

### preventSubmit
> A symbol used to block submitting a prompt
```ts
await arg({
  placeholder: 'Try to submit text less than 10 characters',
  onSubmit: async input => {
    if (input.length < 10) {
      setHint('Text must be at least 10 characters. You entered ' + input.length)
      setEnter('Try Again')
      return preventSubmit
    }
```

### wait
> Wait for a number of milliseconds
```ts
div(md(`Enjoying your wait?`))
await wait(1000)
div(md(`I waited 1 second. Let's wait some more!`))
await wait(1000)
await div(md(`All done!`))
```

### exit
> Exit the script completely
```ts
// Prevent the script from running for more than 1 second
setTimeout(() => {
  exit()
}, 1000)

await arg('I will exit in 1 second')
```

## SDK Utils

### kitPath
> Create a path relative to the kit directory.

### kenvPath
> Create a path relative to the "kenv" (kit environment) directory
```ts
const scriptsPath = kenvPath('scripts')
const scripts = await readdir(scriptsPath)
await editor(JSON.stringify(scripts, null, 2))
```

### tmpPath
> Create a path relative to a "kit" directory in the system temp directory
```ts
const tmpTestTxtPath = tmpPath('test.txt')
const content = await ensureReadFile(tmpTestTxtPath, 'Hello World')

await editor(
  JSON.stringify(
    {
      tmpTestTxtPath,
      content,
```

### getScripts
> Get all scripts
```ts
// Get all scripts from ~/.kit/db/scripts.json
const scripts = await getScripts()
const script = await arg('Select a script', scripts)
await editor(JSON.stringify(script, null, 2))
```

### selectScript
> Allows you to build a custom script selection menu
```ts
import type { Script } from '@johnlindquist/kit'

const script = await selectScript(
  'Select a Shortcut Script to Edit',
  true, // "true" will load from ~/.kit/db/scripts.json cache
  (scripts: Script[]) => scripts.filter(script => script.shortcut)
)
```

## Closing Thoughts

### Alternate Importing
> Also, you can import kit and access the APIs like so:
```ts
import kit from '@johnlindquist/kit'

await kit.arg('Enter your name')
```
````

## File: prompts/docs-mini-condensed.md
````markdown
# Script Kit Prompt Index (Condensed)

Generated by scripts/condense-generation-assets.mjs. Each prompt keeps notes and omits verbose code samples.

## **arg**
> **Notes**:
- strict: false lets you submit any typed text if no matching suggestion is found.
- You can pass a function for dynamic or async suggestions.

## **div**
> **Notes**:
- Great for showing read-only content, images, or info messages.
- You can pass a PromptConfig object for more control (e.g., adding shortcuts).

## **editor**
> **Notes**:
- The built-in Monaco editor supports syntax highlighting for many languages.
- Use onInput, onBlur, or onSubmit to handle editor events.

## **form**
> **Notes**:
- Returns an object keyed by the name attribute of your form elements.
- Perfect for custom layouts or when fields is too restrictive.

## **fields**
> **Notes**:
- Returns an array of strings corresponding to the input values.
- Each field can be a string (for label) or an object for detailed configuration.

## **path**
> **Notes**:
- Lets users pick a file or folder from the filesystem.
- Options include startPath, onlyDirs, showHidden, etc.

## **select**
> **Notes**:
- Returns an **array** of selected items (values).
- Great for scenarios where multiple choices are needed, or for single selection from a rich list.

## **drop**
> **Notes**:
- Returns an array of file objects (each with path, name, etc.) if the user drops files.
- Returns a string if the user drags and drops text (e.g., from a browser).

## **env**
> **Notes**:
- Stores and retrieves variables from ~/.kenv/.env.
- Ideal for API keys, user preferences, and configurations.

## **term**
> **Notes**:
- Launches an embedded terminal window for interactive commands.
- Great for scripts that require user input in a CLI environment or running CLI tools.

## **template**
> **Notes**:
- $1, ${2:default}, etc., act like snippet placeholders you can tab between.
- Use for quick "fill-in-the-blanks" text generation.

## **chat**
> **Notes**:
- Creates a chat-like interface. chat.addMessage() adds messages.
- onSubmit is key for handling user input and responding. By default, submitting closes the chat.

## **micro**
> **Notes**:
- Similar to arg(), but uses a more compact UI.
- Good for quick, ephemeral prompts where screen real estate is a concern.

## **ai**
> **Notes**:
- Returns a function that, when called with input text, generates an AI completion.
- Configure default provider/model via .env (e.g., AI_DEFAULT_PROVIDER, AI_DEFAULT_MODEL).
- For structured JSON output, see generate.

## **generate**
> **Notes**:
- Uses Zod (z) for defining the output schema. Make sure to import { z } from 'zod' if not automatically available or if Script Kit doesn't make z global. (Assuming z is globally available as per kit.d.ts).
- Ideal for converting natural language to structured JSON objects.

## **assistant**
> **Notes**:
- Maintains conversation history. Use addUserMessage, addSystemMessage, etc.
- Stream responses with textStream or get the full interaction with generate().
- Supports tools for extending capabilities. autoExecuteTools: true can simplify tool usage.

## **hotkey**
> **Notes**:
- Captures a key combination (modifiers + one non-modifier key).
- Returns an object with details about the pressed keys and the formatted shortcut string.

## **grid**
> **Notes**:
- Similar to select, but displays choices in a grid layout.
- Useful for visual choices like images or a large number of compact options.
- Returns an array of selected values.

## **eyeDropper**
> **Notes**:
- Activates a system color picker/eyedropper tool.
- Returns an object with the color in various formats (hex, rgb, hsl, etc.).
- Behavior might vary slightly across operating systems.

## Display & Actions
> **setPanel(htmlString)**: Sets HTML content in the panel below the input.
- **setPanel(htmlString)**: Sets HTML content in the panel below the input.
- **setPreview(htmlString)**: Sets HTML content in the preview pane (usually to the right).
- **setHint(textString)**: Sets the hint text displayed below the input/choices.
- **setInput(textString)**: Programmatically sets the text in the input field.

## Windows & UI Control
> **hide() / blur() / focus()**: Control the main prompt's visibility and focus.
- **hide() / blur() / focus()**: Control the main prompt's visibility and focus.
- **show()**: Ensure the main prompt window is visible.
- **setBounds({ x, y, width, height })**: Set the main prompt window's position and size.
- **getActiveScreen()**: Get details about the currently active display (for positioning).

## Editor (`editor` prompt specific API)
> **editor.append("text")**: Appends text at the current cursor position or end.
- **editor.append("text")**: Appends text at the current cursor position or end.
- **editor.setText("new text")**: Replaces the entire content of the editor.
- **editor.getSelection()**: Returns { text: "selected", start: 0, end: 8 }.
- **editor.moveCursor(offset)**: Moves the cursor to a specific character offset.

## Shortcuts & Global Input
> **IMPORTANT**: Always always use await getSelectedText() and await setSelectedText("text") for text manipulation.
- **registerShortcut("cmd+opt+p", callback)**: Registers a global hotkey that runs callback.
- **unregisterShortcut("cmd+opt+p")**: Removes a previously registered global hotkey.
- **keyboard.type("Hello!")**, keyboard.tap(Key.Enter): Simulate keyboard input. Only use when you need to simulate keyboard input. Otherwise, use getSelectedText() and setSelectedText("text") for text manipulation.
- **mouse.leftClick()**, mouse.setPosition({ x:100, y:100 }): Control the mouse.

## DB & Files
> 1. **db(nameOrData, defaultData?)**: Simple JSON file store in ~/.kenv/db/. 2. **readFile(path)**, **writeFile(path, content)**, **readdir(path)**, **remove(path)**, **move(src, dest)**, **copyFile(src, dest)**, **pathExists(path)**: Standard file system operations (mostly from fs-extra/fs/promises).

## Exec & Shell
> 1. **exec("command with args", options?)**: Execute a shell command (uses execa). 2. **$(strings, ...values)** (zx-like template literal): 3. **cd(directory)**, **pwd()**, **which(command)**: Shell navigation and utility commands (from shelljs).

## Network
> **get(url, config?)**, **post(url, data?, config?)**, **put(url, data?, config?)**, **patch(url, data?, config?)**, **del(url, config?)**: Axios-based HTTP request functions.
- **get(url, config?)**, **post(url, data?, config?)**, **put(url, data?, config?)**, **patch(url, data?, config?)**, **del(url, config?)**: Axios-based HTTP request functions.

## System & OS Interaction
> **say("text to speak")**: Text-to-speech.
- **say("text to speak")**: Text-to-speech.
- **beep()**: Plays the system beep sound.
- **getSelectedText()**: Copies selected text from the foreground application.
- **setSelectedText("text to paste")**: Pastes text into the foreground application.

## Audio/Video
> **mic(config?)**: Record audio from microphone, returns Buffer. mic.start(config?) / mic.stop() for streaming.
- **mic(config?)**: Record audio from microphone, returns Buffer. mic.start(config?) / mic.stop() for streaming.
- **webcam(config?)**: Capture an image from webcam, returns Buffer.
- **playAudioFile(filePath)**: Plays an audio file.

## Utility
> **inspect(object)**: Opens a new editor window with a JSON representation of the object.
- **inspect(object)**: Opens a new editor window with a JSON representation of the object.
- **dev(object)**: Opens Chrome DevTools with the object assigned to x in the console.
- **uuid()**: Generates a random UUID string.
- **createChoiceSearch(choices, config)**: Utility for creating efficient client-side search functions for choices.

## Common Aliases & Libraries
> **path.join(...)**, path.basename(...), etc.: Standard Node.js path module functions are available on the global path object.
- **path.join(...)**, path.basename(...), etc.: Standard Node.js path module functions are available on the global path object.
- **chalk**: For colorizing terminal output (e.g., console.log(chalk.blue("Hello"))).
- **replace(config)**: Replaces text in files (from replace-in-file).

## Script Flow Control
> **submit(valueToReturn)**: Closes the current prompt and returns valueToReturn from the prompt function.
- **submit(valueToReturn)**: Closes the current prompt and returns valueToReturn from the prompt function.
- **exit(exitCode?)**: Terminates the script immediately.
- **wait(milliseconds)**: Pauses script execution for a specified duration.

## Cron / System Events (Metadata)
> Use // Schedule: cronExpression (e.g., // Schedule: 0 * * * * for hourly) for scheduled scripts.
- Use // Schedule: cronExpression (e.g., // Schedule: 0 * * * * for hourly) for scheduled scripts.
- Use // System: eventName (e.g., // System: wake) to trigger scripts on system events.
````

## File: prompts/GUIDE-PLAYBOOK.md
````markdown
# Script Kit Playbook (Condensed)

Generated by scripts/condense-generation-assets.mjs. Each topic keeps the first summary and the first example snippet.

## Running a Script
> Press cmd+; (or ctrl+; on Windows) to open the Script Kit prompt. Search for the script you want to run and press enter to run it.

## Debugging a Script
> With the prompt open, run a script with cmd+enter (ctrl+enter on Windows) to launch the script in debug mode. An inspector will appear alongside the script, allowing you to inspect current values and step through it line by line. Use the debugger statement anywhere in your script to create a breakpoint where your script will pause. (When running the script normally, the debugger statement is simply ignored.)
```js
let response = await get("https://api.github.com/repos/johnlindquist/kit")

// The inspector will pause your script so you can examine the value of "response""
debugger
```

## Create a Script
> Keep your scripts in ~/.kenv/scripts ("kenv" stands for "Kit Environment").

## Naming a Script
> The file name of the script is lowercased and dashed like hello-world.js by convention. You can add an additional //Name: Hello World to the top of your script for a more friendly name to appear when searching in the prompt.
```js
//Name: Hello World
```

## // Shortcut Metadata
> Use the // Shortcut metadata to add a global keyboard shortcut to any script
```js
// Shortcut: cmd shift j

import "@johnlindquist/kit"

say(`You pressed command shift j`)
```

## Input Text with `await arg()`
> The simplest form of input you can accept from a user is an arg()
```js
// Name: Input Text

import "@johnlindquist/kit"

let name = await arg("Enter your name")

await div(md(`Hello, ${name}`))
```

## Select From a List of Strings
```js
// Name: Select From a List

import "@johnlindquist/kit"

let fruit = await arg("Pick a fruit", [
  "Apple",
  "Banana",
  "Cherry",
```

## Select From a List of Objects
```js
// Name: Select From a List of Objects

import "@johnlindquist/kit"

let { size, weight } = await arg("Select a Fruit", [
  {
    name: "Apple",
    description: "A shiny red fruit",
```

## Select from a Dynamic List
```js
// Name: Select From a Dynamic List

import "@johnlindquist/kit"

await arg("Select a Star Wars Character", async () => {
  // Get a list of people from the swapi api
  let response = await get("https://swapi.dev/api/people/")
```

## Display a Preview When Focusing a Choice
```js
// Name: Display a Preview When Focusing a Choice

import "@johnlindquist/kit"

let heights = [320, 480, 640]
let choices = heights.map(h => {
  return {
    name: `Kitten height: ${h}`,
```

## Display HTML Beneath the Input
> If the second argument to arg() is a string, it will be displayed beneath the input as HTML.
```js
// Just a string
await arg(
  "Select a fruit",
  md(`I recommend typing "Apple"`) // "md" converts strings to HTML
)
```

## This is just information
> Usually to help you make a choice

## Display Only HTML
> Use await div('') to display HTML.
```js
// Name: Display HTML

import "@johnlindquist/kit"

await div(`<h1>Hello World</h1>`)
```

## Display HTML with CSS
> Script Kit bundles Tailwind CSS.
```js
// Name: Display HTML with CSS

import "@johnlindquist/kit"

await div(
  `<h1 class="p-10 text-4xl text-center">Hello World</h1>`
)
```

## Display Markdown
> The md() function will convert Markdown into HTML that you can pass into div. It will also add the default Tailwind styles so you won't have to think about formatting.
```js
// Name: Display Markdown

import "@johnlindquist/kit"

let html = md(`# Hello World`)

await div(html)
```

## Create a Widget
> Use the widget method to spawn a new, persisting window that is disconnected from the script.
```js
await widget(`
<div class="bg-black text-white h-screen p-5">
    Hello there!
<div>

`)
```

## Set Options using Flags
> To add an options menu to your choices, you must provide a flags object. If one of the keyboard shortcuts are hit, or the user selects the option, then the flag global will have the matching key from your flags set to true:
```js
let urls = [
  "https://scriptkit.com",
  "https://egghead.io",
  "https://johnlindquist.com",
]

let flags = {
  open: {
```

## Store Simple JSON data with db
> The db helpers reads/writes to json files in the ~/.kenv/db directory. It's meant as a simple wrapper around common json operations.
```js
// Name: Database Read/Write Example
// Description: Add/remove items from a list of fruit

let fruitDb = await db(["apple", "banana", "orange"])

// This will keep prompting until you hit Escape
while (true) {
  let fruitToAdd = await arg(
```

## Watch Files to Trigger Scripts
> The // Watch metadata enables you to watch for changes to a file on your system.
```js
// Name: Speak File
// Watch: ~/speak.txt

import "@johnlindquist/kit"

let speakPath = home("speak.txt")

try {
```

## Run Shell Commands
> Script Kit bundles zx as the global $
```js
await $`cat package.json | grep name`

let branch = await $`git branch --show-current`
await $`dep deploy --branch=${branch}`

await Promise.all([
  $`sleep 1; echo 1`,
  $`sleep 2; echo 2`,
```

## Make HTTP Requests with get, put, post, and del
> The get, post, put, and del methods use the axios API
```js
// Name: Get Example

import "@johnlindquist/kit"

let response = await get(
  "https://scriptkit.com/api/get-example"
)
```

## Download Files
> Use download to download a file from a url:
```js
// Name: Download a File

import "@johnlindquist/kit"

let url = "https://www.scriptkit.com/assets/logo.png"
let buffer = await download(url)

let fileName = path.basename(url)
```

## Read a Text File
> You can use readFile to read a text file from your system:
```js
// Name: Read a Text File

import "@johnlindquist/kit"

// Download a readme for the sake of the example
let fileUrl = `https://raw.githubusercontent.com/johnlindquist/kit/main/README.md`
let filePath = home("README.md")
let buffer = await download(fileUrl)
```

## Create a Text File
```js
// Name: Create a Text File

import "@johnlindquist/kit"

let filePath = await path() // Select a path that doesn't exist

let exists = await pathExists(filePath)
```

## Live Edit a Text File
```js
// Name: Update a Text File

import "@johnlindquist/kit"

let filePath = home(`my-notes.md`)

// `ensureReadFile` will create the file with the content
// if it doesn't exist
```

## Run a Script on a Schedule
> Use cron syntax to run scripts on a schedule. The following example will show a notification to stand up and stretch every 15 minutes.
```js
// Name: Stand Up and Stretch
// Schedule: */15 * * * *

import "@johnlindquist/kit"

notify(`Stand up and stretch`)
```

## Environment Variables
> The env helper will read environment variables from ~/.kenv/.env. If the variable doesn't exist, it will prompt you to create it.
```js
// Name: Env Example

import "@johnlindquist/kit"

let KEY = await env("MY_KEY")

await div(md(`You loaded ${KEY} from ~/.kenv/.env`))
```

## Environment Variable Async Prompt
> If you pass a function as the second argument to env, it will only be called if the variable doesn't exist. This allows you to set Enviroment Variables from a list, an API, or any other data source.
```js
// Name: Choose an Environment Variable

import "@johnlindquist/kit"

let MY_API_USER = await env("MY_API_USER", async () => {
  return await arg("Select a user for your API", [
    "John",
    "Mindy",
```

## Share as a Gist, Link, URL, or Markdown
> The Script Kit main window also includes many other share options:
- Share as Gist <kbd>cmd+g</kbd>: Creates as Gist of the selected script, then copies the URL to the clipboard
- Share as Link <kbd>opt+s</kbd>: Creates a private installable kit://link to the selected script, then copies the URL to the clipboard. These links are very long as they encode the entire script into the URL.
- Share as URL <kbd>opt+u</kbd>: Creates a Gist of the selected script, then copies an installable public URL to the clipboard

## Get Featured
> Featured scripts are displayed in:
- The Community tab of the Script Kit main window
- On the Community Scripts page

## Experiment with Data in Chrome DevTools
```js
// Name: Play with Data in Chrome DevTools

import "@johnlindquist/kit"

// Will open a standalone Chrome DevTools window
// The object passed in will be displayed
// You can access the object using `x`, e.g., `x.message` will be `Hello world`
dev({
```

## // Shortcode Metadata
> A shortcode allows you quickly run a script without needing to search for it.
```js
// Shortcode: oi

import "@johnlindquist/kit"

say(`You pressed option i`)
```

## Quick Submit from Hint
> A common pattern from Terminal is to quickly submit a script from a hint. Using a bracket around a single character will submit that character when pressed.
```js
import "@johnlindquist/kit"

let value = await arg({
  placeholder: "Continue?",
  hint: `Another [y]/[n]`,
})

if (value === "y") {
```

## Quick Submit from Choice
> If you need to provide a little more information to the user, use a choice instead of a hint. This allows you to provide a full value that will be submitted instead of just the single letter.
```js
import "@johnlindquist/kit"

let value = await arg("Select a food", [
  {
    name: "[a]pple",
    value: "apple",
  },
  {
```

## Run Scripts from Other Apps
> Are you a fan of one of these amazing tools? Keyboard Maestro
- Keyboard Maestro
- Better Touch Tool
- Karabiner
```bash
~/.kit/kar center-app
```

## Select a Path
```js
// Name: Select a Path

import "@johnlindquist/kit"

let filePath = await path()

await div(md(`You selected ${filePath}`))
```

## Select a Path with Options
```js
// Name: Select a Path with Options

import "@johnlindquist/kit"

await path({
  hint: `Select a path containing JS files`,
  onlyDirs: true,
  onChoiceFocus: async (input, { focused }) => {
```

## Select from Finder Prompts
```js
// Name: Select from Finder Prompt

import "@johnlindquist/kit"

let filePath = await selectFile()

let folderPath = await selectFolder()
```

## Built-in Terminal
> > The shell defaults to zsh. You can change your shell by setting the KIT_SHELL environment variable in the ~/kenv/.env, but most of the testing has been done with zsh.
```js
// Name: Run Commands in the Terminal

import "@johnlindquist/kit"

await term({
  //defaults to home dir
  cwd: `~/.kenv/scripts`,
  command: `ls`,
```

## Built-in Editor
> Script Kit ships with a built-in version of the Monaco editor. Use await editor() to switch to the editor prompt.
```js
// Name: Editor Example

import "@johnlindquist/kit"

let result = await editor()

await div(md(result))
```

## Load Text in the Editor
```js
// Name: Load Text Into the Editor

import "@johnlindquist/kit"

let { data } = await get(
  `https://raw.githubusercontent.com/johnlindquist/kit/main/README.md`
)
```

## Add ~/.kit/bin to $PATH
> > This is similar to VS Code's "Add code to path"
```bash
~/.kit/bin/kit
```

## Required Permissions for Features
> Kit.app requires accessibility permission for the following reasons: Watch user input to trigger Snippets and Clipboard History
- Watch user input to trigger Snippets and Clipboard History
- Send keystrokes to trigger for setSelectedText, getSelectedText, keyboard.type and others
- In the future, recording Macros, mouse actions, and more

## Submit From Live Data
> Some scenarios require setInterval or other "live data" utils. This means you can't use await on the arg/div/textarea/etc because await prevents the script from continuing on to start the setInterval.
```js
let intervalId = 0
div(md(`Click a value`)).then(async value => {
  clearInterval(intervalId)

  await div(md(value))
})

intervalId = setInterval(() => {
```

## Strict Mode
> strict is enabled by default and it forces the user to pick an item from the list, preventing them from entering their own text.
```js
// If the list is completely filtered, hitting enter does nothing.
let fruit = await arg(`You can only pick one`, [
  `Apple`,
  `Banana`,
  `Orange`,
])

// If the list is completely filtered, hitting enter sends whatever
```

## Quick Keys
> A quick key allows you to bind a single key to submit a prompt.
```js
//Type "y" or "n"
let confirm = await arg({
  placeholder: "Eat a taco?",
  hint: `[y]es/[n]o`,
})

console.log(confirm) //"y" or "n"
```

## Position a Widget on Screen
> You can control the size/position of each show window you create, but you'll need some info from the current screen (especially with a multi-monitor setup!) to be able to position the window where you want it:
```js
let width = 480
let height = 320

let { workArea } = await getActiveScreen()
let { x, y, width: workAreaWidth } = workArea

await widget(
  md(`
```

## Update on Input
> When you pass a function as the second argument of arg, you can take the current input and return a string. Kit.app will then render the results as HTML. The simplest example looks like this:
```js
await arg("Start typing", input => input)
```

## Clone Git Repos with degit
> We're developers. We clone project templates from github. degit is available on the global scope for exactly this scenario.
```js
let projectName = await arg("Name your project")
let targetDir = home("projects", projectName)

await degit(`https://github.com/sveltejs/template`).clone(
  targetDir
)

await edit(targetDir)
```

## View Logs
> When you use console.log() in a script, it writes the log out to a relative directory.
```sh
tail -f ~/.kenv/logs/my-script.log
```

## Save webpage as a PDF
> You can save any webpage as a PDF.
```js
// Name: Save news as PDF

import "@johnlindquist/kit"

const pdfResults = await getWebpageAsPdf('https://legiblenews.com');

await writeFile(home('news.pdf'), pdfResults);
```

## Take screenshot of webpage
> You can take a screenshot of any webpage.
```js
// Name: Take screenshot of news webpage

import "@johnlindquist/kit"

const screenshotResults = await getScreenshotFromWebpage('https://legiblenews.com', {
  screenshotOptions: { fullPage: true },
});
```

## Scrape content from a webpage
> You can scrape content from a webpage. The first time you run this, you will be prompted to install Playwright.
```js
// Name: Scrape John's pinned Github repositories

import "@johnlindquist/kit"

const items = await scrapeSelector(
  'https://github.com/johnlindquist',
  // CSS Selector to target elements
  '.pinned-item-list-item-content > div > a',
```

## Missing Something?
> This Guide constantly evolving. If you're missing something, suggest an edit to the docs or open an issue on GitHub.
````

## File: prompts/kit-types.min.d.ts
````typescript
// Condensed kit types generated by scripts/condense-generation-assets.mjs
â‹®----
// File: core.d.ts
import type { ChildProcess } from 'node:child_process'
import type { ProcessType, UI, Mode } from '../core/enum.js'
type ModifierKeys = 'cmd' | 'ctrl' | 'shift' | 'option' | 'alt'
export interface Choice<Value = any> {
name: string
slicedName?: string
value?: Value
description?: string
slicedDescription?: string
focused?: string
img?: string
icon?: string
html?: string
hasPreview?: boolean
preview?: string | ((input: string, state: AppState) => string | Promise<string>)
previewPath?: string
  ...
}
export interface ScoredChoice {
item: Choice<{ id: string; name: string; value: any }>
score: number
matches: {
[key: string]: [number, number][]
}
_: string
}
export type PromptBounds = {
x?: number
y?: number
width?: number
height?: number
}
export type PromptDb = {
screens: {
[screenId: string]: {
[script: string]: PromptBounds
}
}
}
export type Shortcut = {
id?: string
key: string
name?: string
value?: any
onPress?: (input: string, state: AppState) => unknown | Promise<unknown>
bar?: 'right' | 'left' | ''
flag?: string
visible?: boolean
condition?: (choice: any) => boolean
}
export interface PromptData {
id: string
key: string
scriptPath: string
description: string
flags: FlagsObject
hasPreview: boolean
keepPreview?: boolean
hint: string
input: string
inputRegex: string
kitArgs: string[]
kitScript: string
  ...
}
export type Choices<Value> = (
| (string | Choice)[]
| Choice<Value>[]
| (() => Choice<Value>[])
| (() => Promise<Choice<Value>[]>)
| Promise<Choice<any>[]>
| GenerateChoices
) & {
preload?: boolean
}
export type Preview =
| string
| void
| (() => string)
| (() => void)
| (() => Promise<string>)
| (() => Promise<void>)
| ((input: string) => string)
| ((input: string) => void)
| ((input: string) => Promise<any>)
| ((input: string) => Promise<void>)
export type Panel =
| string
| void
| (() => string)
| (() => void)
| (() => Promise<string>)
| (() => Promise<void>)
| ((input: string) => string)
| ((input: string) => void)
| ((input: string) => Promise<any>)
| ((input: string) => Promise<void>)
export type Flags = {
[key: string]: boolean | string
} & Partial<Record<ModifierKeys, boolean | string>>
export type FlagsObject = FlagsWithKeys | boolean
export type ActionsConfig = {
name?: string
placeholder?: string
active?: string
}
export type Action = {
name: string
description?: string
value?: any
shortcut?: string
group?: string
flag?: string
visible?: boolean
enter?: string
onAction?: ChannelHandler
condition?: Shortcut['condition']
close?: boolean
index?: number
}
â‹®----
export type PromptConfig = {
validate?: (input: string) => boolean | string | Promise<boolean | string>
choices?: Choices<any> | Panel
actions?: Action[] | Panel
initialChoices?: Choices<any> | Panel
html?: string
formData?: any
className?: string
flags?: FlagsObject
actions?: Action[]
preview?:
| string
| ((input: string, state: AppState) => string | Promise<string> | void | Promise<void>)
  ...
} & Partial<Omit<PromptData, 'choices' | 'id' | 'script' | 'preview'>>
type OptModifier = 'opt' | 'option' | 'alt'
type CmdModifier = 'cmd' | 'command'
type CtrlModifier = 'ctrl' | 'control'
type ShiftModifier = 'shift'
type Modifier = OptModifier | CmdModifier | CtrlModifier | ShiftModifier
type Key = string
type Separator = ' ' | '+'
type ModifierCombination =
| Modifier
| `${Modifier}${Separator}${Modifier}`
| `${Modifier}${Separator}${Modifier}${Separator}${Modifier}`
| `${Modifier}${Separator}${Modifier}${Separator}${Modifier}${Separator}${Modifier}`
â‹®----
// File: globals.d.ts
type ReadFileOptions = Parameters<typeof import('node:fs/promises').readFile>[1]
â‹®----
// File: io.d.ts
import { EventEmitter } from 'node:events'
export declare enum EventType {
EVENT_KEY_PRESSED = 4,
EVENT_KEY_RELEASED = 5,
EVENT_MOUSE_CLICKED = 6,
EVENT_MOUSE_PRESSED = 7,
EVENT_MOUSE_RELEASED = 8,
EVENT_MOUSE_MOVED = 9,
EVENT_MOUSE_WHEEL = 11,
}
export declare enum WheelDirection {
VERTICAL = 3,
HORIZONTAL = 4,
}
â‹®----
declare interface UiohookNapi {
on(
event: 'input',
listener: (e: UiohookKeyboardEvent | UiohookMouseEvent | UiohookWheelEvent) => void
): this
on(event: 'keydown', listener: (e: UiohookKeyboardEvent) => void): this
on(event: 'keyup', listener: (e: UiohookKeyboardEvent) => void): this
on(event: 'mousedown', listener: (e: UiohookMouseEvent) => void): this
on(event: 'mouseup', listener: (e: UiohookMouseEvent) => void): this
on(event: 'mousemove', listener: (e: UiohookMouseEvent) => void): this
on(event: 'click', listener: (e: UiohookMouseEvent) => void): this
on(event: 'wheel', listener: (e: UiohookWheelEvent) => void): this
}
â‹®----
on(
on(event: 'keydown', listener: (e: UiohookKeyboardEvent)
on(event: 'keyup', listener: (e: UiohookKeyboardEvent)
on(event: 'mousedown', listener: (e: UiohookMouseEvent)
on(event: 'mouseup', listener: (e: UiohookMouseEvent)
on(event: 'mousemove', listener: (e: UiohookMouseEvent)
on(event: 'click', listener: (e: UiohookMouseEvent)
on(event: 'wheel', listener: (e: UiohookWheelEvent)
â‹®----
declare class UiohookNapi extends EventEmitter
â‹®----
start(): void
stop(): void
keyTap(key: number, modifiers?: number[]): void
keyToggle(key: number, toggle: 'down' | 'up'): void
â‹®----
// File: kit.d.ts
import type { Low } from 'lowdb'
import type { format, formatDistanceToNow } from '../utils/date.js'
import type { RestEndpointMethodTypes } from '@octokit/plugin-rest-endpoint-methods'
import type {
Action,
Choice,
Choices,
FlagsObject,
ActionsConfig,
Panel,
Preview,
PromptConfig,
ScoredChoice,
Script,
Shortcut,
Flags,
} from './core.js'
import { ChannelHandler } from './core.js'
import type { ConfigOptions, Options } from 'quick-score'
import type { CoreMessage, Tool, ToolCall, FinishReason, LanguageModel, LanguageModelV1 } from 'ai'
import type { AssistantOutcome, AssistantLastInteraction, ToolCallPart } from '../lib/ai.js' // Import our custom result types
import type { ZodTypeAny } from 'zod' // Import Zod types for global declaration
export interface Arg {
[key: string]: any
â‹®----
export interface Env {
(envKey: string, promptConfig?: string | EnvConfig | (() => Promise<string>)): Promise<string>
[key: string]: any
}
export interface Args extends Array<string> {}
export type UpdateArgs = (args: string[]) => void
export type PathFn = (...pathParts: string[]) => string
export type Inspect = (data: any, extension?: string) => Promise<void>
export type Store = (
key: string,
initialData?: any
) => Promise<InstanceType<typeof import('keyv').default>>
â‹®----
export type DB = <
T = {
[key: string]: any
},
>(
dataOrKeyOrPath?: DBKeyOrPath<T>,
data?: DBData<T>,
fromCache?: boolean
) => Promise<DBReturnType<T>>
â‹®----
export type Browse = (url: string) => Promise<void>
export type Wait = (time: number, submitValue?: any) => Promise<void>
export type GetScripts = (fromCache?: boolean) => Promise<Script[]>
export interface SelectScript {
(message?: string, fromCache?: boolean, xf?: (x: Script[]) => Script[]): Promise<Script>
(
message: PromptConfig,
fromCache?: boolean,
xf?: (x: Script[]) => Script[]
): Promise<Script | string>
}
â‹®----
export type CreateGist = (
content: string,
options?: GistOptions
) => Promise<RestEndpointMethodTypes['gists']['create']['response']['data']>
â‹®----
export type Run = (command?: string, ...args: string[]) => Promise<any>
type Utils = typeof import('../core/utils')
â‹®----
get autoExecuteTools(): boolean
set autoExecuteTools(value: boolean)
get maxHistory(): number
â‹®----
// File: kitapp.d.ts
â‹®----
export type Toast = (toast: string, options?: ToastOptions) => void
export type Prompt = {
closeActions(): Promise<void>
close(): void
openActions(): void
setInput(input: string): void
focus(): Promise<void>
blur(): Promise<void>
hide(): Promise<void>
}
â‹®----
closeActions(): Promise<void>
close(): void
openActions(): void
setInput(input: string): void
focus(): Promise<void>
blur(): Promise<void>
hide(): Promise<void>
â‹®----
export type GetMediaDevices = () => Promise<MediaDeviceInfo[]>
export type GetTypedText = () => Promise<string>
â‹®----
export type PromptBounds = {
x: number
y: number
width: number
height: number
}
export type PromptDb = {
screens: {
[screenId: string]: {
[scriptId: string]: PromptBounds
}
}
}
export type Drop = (placeholder?: string | PromptConfig, actions?: Action[]) => Promise<any>
â‹®----
export type Form = (html: string | PromptConfig, formData?: any, actions?: Action[]) => Promise<any>
â‹®----
export type Div = (html?: string | DivConfig, actions?: Action[])
â‹®----
type AddChoice = (choice: string | Choice)
â‹®----
type SetChoices = (
â‹®----
type SetFormData = (formData: any)
type AppendChoices = (choices: Choice[])
â‹®----
export type SetIgnoreBlur = (ignoreBlur: boolean)
â‹®----
export type SetPanel = (html: string, containerClasses?: string)
â‹®----
export type SetPrompt = (config: Partial<PromptData>)
export type SetPreview = (html: string, containerClasses?: string)
â‹®----
export type Submit = (value: any)
â‹®----
type ScriptHandler = (scriptPath: string)
â‹®----
type ScriptEventHandler = (handler: ScriptHandler)
â‹®----
// File: notify.ts
â‹®----
// File: packages.d.ts
â‹®----
export type Trash = (
â‹®----
// File: platform.d.ts
â‹®----
type PlayAudioFile = (path: string, options?: any)
â‹®----
type StopAudioFile = ()
â‹®----
type CopyPathAsImage = (path: string)
â‹®----
type FileSearch = (name: string, fileSearchOptions?: FileSearchOptions)
â‹®----
type GetActiveTab = (browser?: Browser)
â‹®----
type GetTabs = (browser?: Browser) => Promise<
â‹®----
type FocusTab = (url: string, browser?: Browser)
â‹®----
type ScrapeAttribute = (
â‹®----
type GetScreenshotFromWebpage = (
â‹®----
type GetWebpageAsPdf = (url: string, options?: WebpageAsPdfOptions)
â‹®----
type FocusWindow = (process: string, title: string)
â‹®----
type GetWindowPosition = (process: string, title: string, x: number, y: number)
â‹®----
type SetWindowPosition = (process: string, title: string, x: number, y: number)
â‹®----
type SetWindowSizeByIndex = (
â‹®----
type SetWindowBoundsByIndex = (
â‹®----
type ScatterWindows = ()
â‹®----
type OrganizeWindows = ()
â‹®----
type SetWindowPositionByIndex = (
â‹®----
type SetWindowSize = (process: string, title: string, x: number, y: number)
â‹®----
type SelectDisplay = (includeThumbnails?: boolean)
â‹®----
type TileWindow = (app: string, leftOrRight: 'left' | 'right')
â‹®----
type GetActiveScreen = ()
â‹®----
type GetMousePosition = ()
â‹®----
type GetProcesses = ()
â‹®----
type GetPrompts = () => Promise<Prompt[]>
type AttemptScriptFocus = () => Promise<boolean>
type GetPromptStatus = () => Promise<
â‹®----
type AttemptScriptFocus = () => Promise<boolean>
type GetPromptStatus = () => Promise<
â‹®----
type GetPromptStatus = () => Promise<
â‹®----
type FocusAppWindow = (id: string)
â‹®----
type SetActiveAppPosition = (position: { x: number; y: number }) => Promise<void>
type SetActiveAppSize = (size: { width: number; height: number }) => Promise<void>
type GetActiveAppInfo = () => Promise<
â‹®----
type SetActiveAppSize = (size:
type GetActiveAppInfo = () => Promise<
type GetActiveAppBounds = ()
â‹®----
type GetSelectedFile = ()
â‹®----
type SetSelectedFile = (filePath: string)
â‹®----
type GetSelectedDir = ()
â‹®----
type SelectFile = (message?: string)
â‹®----
type RevealFile = (filePath: string)
â‹®----
type RevealInFinder = (filePath?: string)
â‹®----
type SelectFolder = (message?: string)
â‹®----
type GetSelectedText = ()
â‹®----
type CutText = ()
â‹®----
type Lock = ()
â‹®----
type Logout = ()
type Sleep = ()
type Shutdown = ()
type QuitAllApps = (appsToExclude?: string)
type Say = (text: string, options?: any)
â‹®----
type Beep = ()
â‹®----
type SetSelectedText = (text: string, hide?: boolean)
type KeyStroke = (keyString: string)
â‹®----
type AppleScript = (script: string, options?: any)
â‹®----
// File: pro.d.ts
````

## File: scripts/condense-generation-assets.mjs
````
const root = process.cwd()
â‹®----
const readLines = filePath => fs.readFileSync(filePath, 'utf-8').split(/\r?\n/)
â‹®----
const writeFileSafe = (filePath, content) => {
fs.mkdirSync(path.dirname(filePath), { recursive: true })
fs.writeFileSync(filePath, content.trim() + '\n', 'utf-8')
â‹®----
const stripMarkdownLinks = value => value.replace(/\[(.*?)\]\((.*?)\)/g, '$1')
â‹®----
const cleanSummaryLine = line => stripMarkdownLinks(line).replace(/`([^`]+)`/g, '$1').trim()
â‹®----
const extractSummary = chunk => {
â‹®----
const line = raw.trim()
if (line.startsWith('```')) {
â‹®----
if (line.startsWith('#') || line.startsWith('```') || line.startsWith('|')) continue
if (line.startsWith('<') && line.endsWith('>')) continue
if (line.startsWith('![')) continue
if (line.startsWith('- ') || line.startsWith('* ')) {
collected.push(cleanSummaryLine(line.slice(2)))
â‹®----
collected.push(cleanSummaryLine(line))
if (collected.join(' ').length >= 200) break
â‹®----
return collected.join(' ').replace(/\s+/g, ' ')
â‹®----
const extractBullets = (chunk, limit = 4) => {
â‹®----
bullets.push(cleanSummaryLine(line.slice(2)))
â‹®----
const extractCodeBlock = (chunk, maxLines = 12) => {
const start = chunk.findIndex(line => line.trim().startsWith('```'))
â‹®----
const language = chunk[start].trim().slice(3).trim() || 'ts'
â‹®----
if (line.trim().startsWith('```')) break
â‹®----
body.push(line)
â‹®----
const code = body.join('\n').trim()
â‹®----
const splitByHeading = (lines, pattern) => {
â‹®----
const match = line.match(pattern)
â‹®----
if (current) groups.push(current)
current = { heading: match[1].trim(), content: [] }
â‹®----
current.content.push(line)
â‹®----
const condenseApiDocs = () => {
const inputPath = path.join(root, 'prompts', 'API-GENERATED.md')
const outputPath = path.join(root, 'prompts', 'API-REFERENCE.md')
const lines = readLines(inputPath)
const sections = splitByHeading(lines, /^##\s+(.*)$/)
â‹®----
const childSections = splitByHeading(section.content, /^###\s+(.*)$/)
â‹®----
parts.push(`\n## ${section.heading}`)
â‹®----
const summary = extractSummary(child.content)
const bullets = extractBullets(child.content, 3)
const code = extractCodeBlock(child.content, 8)
parts.push(`\n### ${child.heading}`)
if (summary) parts.push(`> ${summary}`)
for (const item of bullets) parts.push(`- ${item}`)
if (code) parts.push(code.trimStart())
â‹®----
writeFileSafe(outputPath, parts.join('\n'))
â‹®----
const condenseGuide = () => {
const inputPath = path.join(root, 'prompts', 'GUIDE.md')
const outputPath = path.join(root, 'prompts', 'GUIDE-PLAYBOOK.md')
â‹®----
const summary = extractSummary(section.content)
const bullets = extractBullets(section.content, 3)
const code = extractCodeBlock(section.content, 8)
â‹®----
const condenseDocsMini = () => {
const inputPath = path.join(root, 'prompts', 'docs-mini.md')
const outputPath = path.join(root, 'prompts', 'docs-mini-condensed.md')
if (!fs.existsSync(inputPath)) return
â‹®----
const bullets = extractBullets(section.content, 4)
parts.push(`\n## ${section.heading.replace(/^\d+\.\s*/, '')}`)
â‹®----
const countBraces = line => {
const open = (line.match(/\{/g) || []).length
const close = (line.match(/\}/g) || []).length
â‹®----
const truncateBlock = (lines, { maxBodyLines = 20, ellipsis = '  ...' } = {}) => {
â‹®----
const body = lines.slice(1, -1).filter(Boolean)
â‹®----
return [header, ...body.slice(0, maxBodyLines), ellipsis, footer]
â‹®----
const minifyTypes = () => {
const typesDir = path.join(root, 'kit', 'types')
const outputPath = path.join(root, 'prompts', 'kit-types.min.d.ts')
â‹®----
.readdirSync(typesDir)
.filter(file => file.endsWith('.ts') || file.endsWith('.d.ts'))
.sort()
â‹®----
const allowedTypeNames = new Set([
â‹®----
const source = fs.readFileSync(path.join(typesDir, file), 'utf-8')
const withoutBlock = source.replace(/\/\*[\s\S]*?\*\//g, '')
const withoutLine = withoutBlock.replace(/^\s*\/\/.*$/gm, '')
const rawLines = withoutLine.split(/\r?\n/).map(line => line.trim()).filter(line => line.length > 0)
â‹®----
const flushCapture = () => {
â‹®----
processed.push(...truncateBlock(lines, { maxBodyLines: MAX_INTERFACE_LINES }))
â‹®----
processed.push(...truncateBlock(lines, { maxBodyLines: MAX_TYPE_LINES }))
â‹®----
processed.push(...lines)
â‹®----
if (line.startsWith('|') || line.startsWith('&')) {
â‹®----
const interfaceMatch = line.startsWith('export interface ')
const typeMatch = line.startsWith('export type ') && line.includes('{')
â‹®----
line.startsWith('declare namespace ') ||
line.startsWith('declare module ') ||
line.startsWith('declare global ')
const typeNoBlockMatch = line.startsWith('export type ') && !line.includes('{')
â‹®----
const name = (line.match(/^export\s+type\s+([A-Za-z0-9_]+)/) || [])[1]
if (name && !allowedTypeNames.has(name)) {
â‹®----
const typeNameMatch = line.match(/^export\s+(?:interface|type)\s+([A-Za-z0-9_]+)/)
â‹®----
const skip = name ? !allowedTypeNames.has(name) : false
â‹®----
hasBlock: line.includes('{'),
â‹®----
braceBalance = countBraces(line)
â‹®----
flushCapture()
â‹®----
capturing.lines.push(line)
if (capturing.hasBlock || line.includes('{') || line.includes('}')) {
braceBalance += countBraces(line)
â‹®----
processed.push(line)
â‹®----
// Remove duplicate blank separators
â‹®----
condensed.push(line)
â‹®----
chunks.push(`\n// File: ${file}\n${condensed.join('\n')}`)
â‹®----
writeFileSafe(outputPath, chunks.join('\n'))
â‹®----
const run = () => {
condenseApiDocs()
condenseGuide()
condenseDocsMini()
minifyTypes()
â‹®----
run()
````

## File: prompts/SYSTEM.md
````markdown
You are a specialized TypeScript script generator specifically for the Script Kit environment (https://scriptkit.com).
Your primary goal is to create a functional, minimal draft script based on the user's prompt (<USER_PROMPT>).

CRITICAL OUTPUT RULES:

1.  Your output MUST be ONLY the raw TypeScript code for the Script Kit script.
2.  DO NOT include any explanations, introductions, summaries, or conversational text before or after the code.
3.  DO NOT wrap the code in markdown fences like `typescript ... ` or `...`.
4.  The script MUST start directly with the required metadata comments (see <METADATA> section).

SCRIPTING REQUIREMENTS:

1.  Use ESM syntax (`import`, `export`). NEVER use `require`.
2.  Utilize Script Kit's global functions (`arg`, `env`, `$` etc.) directly where appropriate. Do not import them unless absolutely necessary from a sub-path (rare). Refer to <API_DOCS> and <GUIDE>.
3.  Write asynchronous code using top-level `await`. Do not wrap the main logic in an `async function main() {...}` unless strictly necessary for complex control flow.
4.  Focus on the core functionality requested by the user. Keep the draft minimal.

CONTEXT:
Rely heavily on the provided <API_DOCS>, <GUIDE>, and <EXAMPLES> for correct API usage and common patterns. Pay attention to the <METADATA> requirements.

Final Check: Review your generated code one last time before outputting. Ensure it contains ONLY the raw TypeScript code, starting precisely with the `// Name:` metadata comment, and includes `import "@johnlindquist/kit";` appropriately. Remove ALL surrounding text, explanations, apologies, or markdown formatting.
````

## File: app/api/generate-ai-gateway/prompt.ts
````typescript
import {
  getAPIDocsContent,
  getDocsMini,
  getExampleScripts,
  getGuideContent,
  getKitTypes,
  getMetadataContent,
  getPromptContent,
  getSystemContent,
} from '@/lib/generation'
â‹®----
/*

metadata = {
    name: "Name of the Script",
    description: "Description of the script",
    author: "Author from above"
}
    */
````

## File: lib/generation.ts
````typescript
import fs from 'fs'
import path from 'path'
â‹®----
// Interface for consistent user info across generation
export interface UserInfo {
  name: string | null
  username: string
  fullName: string | null
  image: string | null
}
â‹®----
interface SessionUser {
  id: string
  name?: string | null | undefined
  email?: string | null | undefined
  image?: string | null | undefined
}
â‹®----
interface DbUser {
  id: string
  username: string
}
â‹®----
// Helper to extract user info consistently
export function extractUserInfo(session:
â‹®----
export function getKitTypes()
â‹®----
// Function to read example scripts
â‹®----
export function getExampleScripts()
â‹®----
export function getMetadataContent()
â‹®----
export function getSystemContent()
â‹®----
export function getGuideContent()
â‹®----
export function getAPIDocsContent()
â‹®----
export function getDocsMini()
â‹®----
// Function to read docs-mini.md
export function getPromptContent()
â‹®----
// Simple code fence cleaner for script generation
export function cleanCodeFences(text: string): string
â‹®----
// First, remove any standalone "typescript" or "ts" lines (case insensitive)
â‹®----
// Remove opening code fences with optional language specifier
â‹®----
// Remove closing code fences
â‹®----
// Clean up any triple or more newlines while preserving exactly two
â‹®----
// Remove leading newlines and whitespace before first non-empty line
â‹®----
// Ensure proper line breaks around metadata comments
// cleaned = cleaned.replace(/^(\/\/ Name:.*?)$/m, '$1\n')
// cleaned = cleaned.replace(/^(\/\/ Description:.*?)$/m, '$1\n')
// cleaned = cleaned.replace(/^(\/\/ Author:.*?)$/m, '$1\n')
â‹®----
// // Also ensure no double newlines between metadata
// cleaned = cleaned.replace(/^(\/\/ Name:.*?\n\n)(\/\/ Description:)/gm, '$1$2')
// cleaned = cleaned.replace(/^(\/\/ Description:.*?\n\n)(\/\/ Author:)/gm, '$1$2')
â‹®----
// Return without trimming to preserve whitespace
â‹®----
// Advanced code extractor for importing scripts from markdown
export function extractScriptFromMarkdown(text: string): string
â‹®----
// Standard code blocks with language
â‹®----
// Code blocks with no language
â‹®----
// Code blocks with language but no newline
â‹®----
// Code blocks with no language or newline
â‹®----
// Try each pattern
â‹®----
// Get the code from the first capture group
â‹®----
// If the extracted code looks like valid script content, use it
â‹®----
// If we get here and the content has markdown-like content before a code block,
// try to find the first code-like section
â‹®----
// If all else fails, return the cleaned input
â‹®----
// Helper function to extract metadata and code from markdown content
export function parseScriptFromMarkdown(content: string):
â‹®----
// Extract metadata from comments at the top
â‹®----
// Look for metadata in comments at the start
â‹®----
// If we didn't find a name in comments, try to extract from metadata block
â‹®----
// Try to match the metadata object format: metadata = { name: "Script Name" }
â‹®----
// If we found a 'Name' field, let's keep it short
â‹®----
// Truncate metadata.name if it's too long
â‹®----
// Get the actual code content
````

## File: app/api/generate-ai-gateway/route.ts
````typescript
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/prisma'
import { authOptions } from '../auth/[...nextauth]/route'
import { logInteraction } from '@/lib/interaction-logger'
import { type ModelMessage, streamText, type LanguageModel } from 'ai'
import { DRAFT_PASS_PROMPT } from './prompt'
import { extractUserInfo } from '@/lib/generation'
import type { GatewayModelId } from '@ai-sdk/gateway'
import { gateway } from '@/lib/ai-gateway'
import { GenerateRequestSchema } from '@/lib/schemas'
â‹®----
// Explicitly declare this route uses Node.js runtime
â‹®----
export async function POST(req: Request)
â‹®----
// Add detailed cookie logging to understand session state
â‹®----
// Enhanced session retrieval with detailed logging
â‹®----
// Log the request object details for NextAuth
â‹®----
// Extremely detailed session logging
â‹®----
// Test if the issue is with the specific user properties
â‹®----
// Get user info from request
â‹®----
// Check for CLI API key first
â‹®----
// Skip auth for CLI tools with valid API key
â‹®----
// Fall back to session auth for web requests
â‹®----
// More granular checks
â‹®----
// Parse and validate the request body
â‹®----
// The prompt is already validated by Zod schema, so this check is now redundant
// But kept for consistency with logging
â‹®----
// Fetch structured script kit docs
â‹®----
// Decide if this is a critical failure or if we can proceed without these docs
// For now, proceeding with empty content
â‹®----
// Proceeding with empty content
â‹®----
// Create a new script record and store the ID for later use
â‹®----
// Handle usage tracking (simplified)
â‹®----
// Get or create usage record
â‹®----
// Create user and usage if they don't exist
â‹®----
// Fetch database user info for extractUserInfo
â‹®----
// Check daily limit
â‹®----
// Increment usage count
â‹®----
// Get user info for prompt using extractUserInfo
â‹®----
// Generate draft script using Vercel AI Gateway
â‹®----
// Convert to messages format for AI Gateway
â‹®----
// Handle immediate errors (like cost limit exceeded)
â‹®----
// Return the AI stream as a Response
// The result provides a readable stream of strings in `textStream`.
â‹®----
async start(controller)
â‹®----
// Send script ID first
â‹®----
// Check if error occurred during streaming
````
